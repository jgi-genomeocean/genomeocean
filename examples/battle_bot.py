import argparse
import subprocess
import pandas as pd
import os

def run_autocomplete(config_file, model_dir, num_sequences, output_prefix, scoring_method):
    """Runs the autocomplete workflow."""
    command = [
        'bash',
        './run_auto_complete_workflow.sh',
        config_file,
        model_dir,
        str(num_sequences),
        output_prefix,
        scoring_method
    ]
    result = subprocess.run(command, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"Error running autocomplete for {output_prefix}:")
        print(result.stderr)
        return False
    return True

def main():
    parser = argparse.ArgumentParser(description="Battle-bot for gene autocompletion.")
    parser.add_argument("model1_genes", help="CSV file with genes generated by model1.")
    parser.add_argument("model2_dir", help="Directory of model2 for autocompletion.")
    args = parser.parse_args()

    # Read the generated genes from model1
    try:
        model1_df = pd.read_csv(args.model1_genes)
    except FileNotFoundError:
        print(f"Error: {args.model1_genes} not found.")
        return

    results = []
    
    # Loyop through each gene and run autocompletion
    for index, row in model1_df.iterrows():
        gene_id = row['id']
        if os.path.exists(f"battle_bot_output_{gene_id}.csv"):
            continue
        gene_seq = row['gene']
        orf_len = len(row['ORF'])
        gene_len = len(gene_seq)

        # Create a temporary config file for this gene
        config_content = f"""
sequence="{gene_seq}"
start=0
end={gene_len - 1}
strand=1
pstart=0
pend=300
min=1000
max=1024
sstart=300
send={3 * orf_len}
foldmason="foldmason"
"""
        config_filename = f"temp_config_{gene_id}.txt"
        with open(config_filename, "w") as f:
            f.write(config_content)

        print(f"Running autocomplete for {gene_id}...")
        success = run_autocomplete(
            config_filename,
            args.model2_dir,
            20,  # num_sequences (trials)
            f"battle_bot_output_{gene_id}",
            "pairwise"  # scoring_method
        )

        scores_str = ""
        success_level = 0

        if success:
            output_csv = f"battle_bot_output_{gene_id}.csv"
            try:
                scores_df = pd.read_csv(output_csv)
                scores = scores_df['score']
                scores_str = ",".join(map(str, scores))
                
                if sum(s >= 0.8 for s in scores) >= 2:
                    success_level = 2
                elif sum(s >= 0.6 for s in scores) >= 2:
                    success_level = 1
                
                os.remove(output_csv)

            except FileNotFoundError:
                print(f"Error: {output_csv} not found. Cannot perform scoring.")
        else:
            print(f"Autocomplete failed for {gene_id}")

        results.append({
            'id': gene_id,
            'gene': gene_seq,
            'scores': scores_str,
            'success': success_level
        })

        # Clean up the temporary config file
        os.remove(config_filename)

    # Save results to a CSV file
    results_df = pd.DataFrame(results)
    results_df.to_csv("battle_bot_results.csv", index=False)

    print("\nBattle-bot summary:")
    print(f"Successful (level 2): {(results_df['success'] == 2).sum()}")
    print(f"Successful (level 1): {(results_df['success'] == 1).sum()}")
    print(f"Unsuccessful: {(results_df['success'] == 0).sum()}")
    print("\nDetailed results saved to battle_bot_results.csv")


if __name__ == "__main__":
    main()
